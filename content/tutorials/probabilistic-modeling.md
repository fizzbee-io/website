---
title: Probabilistic Modeling
weight: 25
---

In this tutorial, we will introduce the basics of probabilistic modeling with FizzBee.

When building distributed systems, behavioral correctness is only one part of the story. 
Performance, reliability, and security are also important. Probabilistic modeling 
is a powerful tool for reasoning about these properties. It allows us to 
reason about the likelihood of certain events happening, such as a 
message being lost or a node failing or error rate of an api call and so on.

Also, probabilistic modeling is a prerequisite for performance modeling like 
expected latency, throughput, availability SLAs and so on, that we will learn in 
the next tutorial.


{{< toc >}}

## Introduction
If you need to reason about performance of a system, you need to reason about probability.
In this tutorial, we will see probabilistic modeling, and in the next one, we will how to 
model performance.

This tutorial assumes, you have gone through at least the [FizzBee getting started](/tutorials/getting-started).

## Alternatives
PRISM model checker is the state of the art for probabilistic model checking. Unfortunately, 
the language is hard to use, and it is not suitable for large state spaces. Unlike PRISM,
FizzBee uses Python-like language that is incredibly easy for anyone to quickly get started,
make it a powerful yet easier to use alternative to PRISM.

In this page, we will point to PRISM's examples to show how FizzBee is easier to use.

## Installation
As of now, the online playground only supports the basic behavioral model checking. To use
the probabilistic modeling, you need to use the CLI. 

See: https://github.com/fizzbee-io/fizzbee for installation instructions.

## Basics - Simple Coin

Create a folder for this example. Let's call it `simple_coin`.

`samples/simple-coin/CoinToss.fizz`:
```python
action Toss:
  oneof:
    return "head"
    return "tail"
```

Since we just want to limit to a single coin toss, the easiest way to do is, say that in fizz.yaml file.

`samples/simple-coin/fizz.yaml`:
```yaml
options:
  maxActions: 1

```

Now, run the model checker.
Assuming, you have fizzbee installed, and fizz is in your path, you can run the following command.
```bash
fizz samples/simple-coin/CoinToss.fizz

```
You should see something like.
```bash
Model checking samples/simple-coin/CoinToss.json
configFileName: samples/simple-coin/fizz.yaml
StateSpaceOptions: options:{max_actions:1 max_concurrent_actions:1}
Nodes: 4, elapsed: 78.25µs
Time taken for model checking: 83.209µs
Writen graph dotfile: samples/simple-coin/out/run_2024-05-07_23-46-17/graph.dot
To generate svg, run: 
dot -Tsvg samples/simple-coin/out/run_2024-05-07_23-46-17/graph.dot -o graph.svg && open graph.svg
Max Depth 2
PASSED: Model checker completed successfully
Writen 1 node files and 1 link files to dir fizzbee/simple-coin/out/run_2024-05-07_23-46-17
```

{{% graphviz %}}

digraph G {
"0x140000ad560" [label="init
Actions: 0, Forks: 0

", color="black" penwidth="2" ];
"0x140000ad560" -> "0x140000ad680" [label="Toss", color="black" penwidth="1" ];
"0x140000ad680" [label="Toss
Actions: 1, Forks: 1

Threads: 0/1
", color="black" penwidth="1" ];
"0x140000ad680" -> "0x140000adb60" [label="", color="black" penwidth="1" ];
"0x140000adb60" [label="yield
Actions: 1, Forks: 2
Returns: {\"Toss\":\"\"head\"\"}
", color="black" penwidth="2" ];
"0x140000ad680" -> "0x140000adc80" [label="", color="black" penwidth="1" ];
"0x140000adc80" [label="yield
Actions: 1, Forks: 2
Returns: {\"Toss\":\"\"tail\"\"}
", color="black" penwidth="2" ];
}


{{% /graphviz %}}

What the code says, is Toss action can return either "head" or "tail". At present, we haven't specified the probability
of each outcome. If not specified, fizzbee assumes equal probability for each branch.

#### Running the performance model checker

The CLI takes three parameters, we will use the third one later.
--states is the directory where the states are stored. This will be printed when running `fizz` command.
--source is the source file, but use the json path, that is also generated by the `fizz` command.

```bash
bazel-bin/performance/performance_bin \
  --states samples/simple-coin/out/run_2024-05-07_23-46-17/  \
  --source samples/simple-coin/CoinToss.json
  ##
  ## Ignore the debug logs
  ##
   2: 0.50000000 state: {} / returns: {"Toss":"\"head\""}
   3: 0.50000000 state: {} / returns: {"Toss":"\"tail\""}
```
Starting from the root node, if you follow the graph, taking each branch with equal probability,
the these are the final states, and they both have equal probability.

### Defining custom probabilities
To define the probability, we need a way to identify the choice. For this,
we FizzBee has labels. The labels are specified with a backtick (`).

```python
action Toss:
  oneof:
    `head` return "head"
    `tail` return "tail"
```
Rerun the model checker,
```bash
./fizz samples/simple-coin/CoinToss.fizz                                                          
Model checking samples/simple-coin/CoinToss.json
configFileName: samples/simple-coin/fizz.yaml
StateSpaceOptions: options:{max_actions:1 max_concurrent_actions:1}
Nodes: 4, elapsed: 454µs
Time taken for model checking: 467.5µs
Writen graph dotfile: samples/simple-coin/out/run_2024-05-08_00-05-55/graph.dot
To generate svg, run: 
dot -Tsvg samples/simple-coin/out/run_2024-05-08_00-05-55/graph.dot -o graph.svg && open graph.svg
Max Depth 2
PASSED: Model checker completed successfully
Writen 1 node files and 1 link files to dir samples/simple-coin/out/run_2024-05-08_00-05-55
```
open the graph.svg file, and you will see the labels.

{{% graphviz %}}
digraph G {
"0x14000121560" [label="init
Actions: 0, Forks: 0

", color="black" penwidth="2" ];
"0x14000121560" -> "0x14000121680" [label="Toss", color="black" penwidth="1" ];
"0x14000121680" [label="Toss
Actions: 1, Forks: 1

Threads: 0/1
", color="black" penwidth="1" ];
"0x14000121680" -> "0x14000121b60" [label="[Toss.head]", color="black" penwidth="1" ];
"0x14000121b60" [label="yield
Actions: 1, Forks: 2
Returns: {\"Toss\":\"\"head\"\"}
", color="black" penwidth="2" ];
"0x14000121680" -> "0x14000121c80" [label="[Toss.tail]", color="black" penwidth="1" ];
"0x14000121c80" [label="yield
Actions: 1, Forks: 2
Returns: {\"Toss\":\"\"tail\"\"}
", color="black" penwidth="2" ];
}

{{% /graphviz %}}

Now, that we have the labels, we can specify the probabilities.
For that, create another yaml file.

`samples/simple-coin/perf_model_unbiased.yaml`:
```yaml
configs:
  Toss.head:
    probability: 0.5
  Toss.tail:
    probability: 0.5

```
Note: The labels are namespaced to the action/function names. So, to refer to head, use `Toss.head`.

Now, run the performance model checker with the new yaml file.
```bash
bazel-bin/performance/performance_bin \
    --states samples/simple-coin/out/run_2024-05-08_00-05-55/  \
    --source samples/simple-coin/CoinToss.json \
    --perf samples/simple-coin/perf_model_unbiased.yaml
    ##
    ## Ignore the debug logs
    ##
     2: 0.50000000 state: {} / returns: {"Toss":"\"head\""}
     3: 0.50000000 state: {} / returns: {"Toss":"\"tail\""}
```

Of course, nothing exciting yet. Now, lets specify a biased coin.

`samples/simple-coin/perf_model_biased.yaml`:
```yaml
configs:
  Toss.head:
    probability: 0.9
  Toss.tail:
    probability: 0.1

```


Now, run the performance model checker with the new yaml file.
```bash
bazel-bin/performance/performance_bin \
    --states samples/simple-coin/out/run_2024-05-08_00-05-55/  \
    --source samples/simple-coin/CoinToss.json \
    --perf samples/simple-coin/perf_model_unbiased.yaml
    ##
    ## Ignore the debug logs
    ##
   2: 0.90000000 state: {} / returns: {"Toss":"\"head\""}
   3: 0.10000000 state: {} / returns: {"Toss":"\"tail\""}
```

So far, nothing much exciting. But, let us build a couple of bigger examples.

## Simulating a 6-sided die with a fair coin
This is a classic first example in PRISM as well.
https://www.prismmodelchecker.org/tutorial/die.php

The algorithm is simple. Toss the coins three times. Assuming {0,1}, with 3 tosses, you get 8 options.
{000, 001, 010, 011, 100, 101, 110, 111} corresponding to 0-7. So, ignore
000 and 111, and map the rest to 1-6. 

`samples/die/Die.fizz`:
```python
atomic func Toss():
    oneof:
        `head` return 0
        `tail` return 1

atomic action Roll:
  toss0 = Toss()
  while True:
    toss1 = Toss()
    toss2 = Toss()

    if (toss0 != toss1 or toss0 != toss2):
      return 4 * toss0 + 2 * toss1 + toss2

```
Here also we are simulating a single roll, so limit the actions to 1.
`samples/die/fizz.yaml`:
```yaml
options:
  maxActions: 1

```

Now, run the model checker.
```bash
fizz samples/die/Die.fizz
Model checking samples/die/Die.json
configFileName: samples/die/fizz.yaml
StateSpaceOptions: options:{max_actions:1 max_concurrent_actions:1}
Nodes: 14, elapsed: 883.875µs
Time taken for model checking: 894.292µs
Writen graph dotfile: samples/die/out/run_2024-05-08_00-29-07/graph.dot
To generate svg, run: 
dot -Tsvg samples/die/out/run_2024-05-08_00-29-07/graph.dot -o graph.svg && open graph.svg
Max Depth 4
PASSED: Model checker completed successfully
Writen 1 node files and 1 link files to dir samples/die/out/run_2024-05-08_00-29-07
```
Open, the graph.svg file to visualize how the algorithm works.
{{% graphviz %}}
digraph G {
"0x140001218c0" [label="init
Actions: 0, Forks: 0

", color="black" penwidth="2" ];
"0x140001218c0" -> "0x140001219e0" [label="Roll[Toss.call]", color="black" penwidth="1" ];
"0x140001219e0" [label="Roll
Actions: 1, Forks: 1

Threads: 0/1
", color="black" penwidth="1" ];
"0x140001219e0" -> "0x1400020c300" [label="[Toss.head, Toss.call]", color="black" penwidth="1" ];
"0x1400020c300" [label="Stmt:0
Actions: 1, Forks: 2

Threads: 0/1
", color="black" penwidth="1" ];
"0x1400020c300" -> "0x1400020d3e0" [label="[Toss.head, Toss.call]", color="black" penwidth="1" ];
"0x1400020d3e0" [label="Stmt:0
Actions: 1, Forks: 3

Threads: 0/1
", color="black" penwidth="1" ];
"0x1400020d3e0" -> "0x1400020c300" [label="[Toss.head, Toss.call]", color="black" penwidth="1" ];
"0x1400020d3e0" -> "0x14000217c80" [label="[Toss.tail]", color="black" penwidth="1" ];
"0x14000217c80" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"1\"}
", color="black" penwidth="2" ];
"0x1400020c300" -> "0x1400020d680" [label="[Toss.tail, Toss.call]", color="black" penwidth="1" ];
"0x1400020d680" [label="Stmt:1
Actions: 1, Forks: 3

Threads: 0/1
", color="black" penwidth="1" ];
"0x1400020d680" -> "0x14000222cc0" [label="[Toss.head]", color="black" penwidth="1" ];
"0x14000222cc0" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"2\"}
", color="black" penwidth="2" ];
"0x1400020d680" -> "0x14000222f60" [label="[Toss.tail]", color="black" penwidth="1" ];
"0x14000222f60" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"3\"}
", color="black" penwidth="2" ];
"0x140001219e0" -> "0x1400020c4e0" [label="[Toss.tail, Toss.call]", color="black" penwidth="1" ];
"0x1400020c4e0" [label="Stmt:1
Actions: 1, Forks: 2

Threads: 0/1
", color="black" penwidth="1" ];
"0x1400020c4e0" -> "0x14000216720" [label="[Toss.head, Toss.call]", color="black" penwidth="1" ];
"0x14000216720" [label="Stmt:0
Actions: 1, Forks: 3

Threads: 0/1
", color="black" penwidth="1" ];
"0x14000216720" -> "0x14000223f20" [label="[Toss.head]", color="black" penwidth="1" ];
"0x14000223f20" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"4\"}
", color="black" penwidth="2" ];
"0x14000216720" -> "0x14000230240" [label="[Toss.tail]", color="black" penwidth="1" ];
"0x14000230240" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"5\"}
", color="black" penwidth="2" ];
"0x1400020c4e0" -> "0x140002169c0" [label="[Toss.tail, Toss.call]", color="black" penwidth="1" ];
"0x140002169c0" [label="Stmt:1
Actions: 1, Forks: 3

Threads: 0/1
", color="black" penwidth="1" ];
"0x140002169c0" -> "0x14000231200" [label="[Toss.head]", color="black" penwidth="1" ];
"0x14000231200" [label="yield
Actions: 1, Forks: 4
Returns: {\"Roll\":\"6\"}
", color="black" penwidth="2" ];
"0x140002169c0" -> "0x1400020c4e0" [label="[Toss.tail, Toss.call]", color="black" penwidth="1" ];
}

{{% /graphviz %}}

Now, run the probabilistic model checker. Since, we are using a fair coin, no need to
specify the custom probabilities.
```bash
bazel-bin/performance/performance_bin --states samples/die/out/run_2024-05-08_00-29-07/  --source samples/die/Die.json
##
## Ignore the debug logs
##
   8: 0.16666667 state: {} / returns: {"Roll":"1"}
   9: 0.16666667 state: {} / returns: {"Roll":"2"}
  10: 0.16666667 state: {} / returns: {"Roll":"3"}
  11: 0.16666667 state: {} / returns: {"Roll":"4"}
  12: 0.16666667 state: {} / returns: {"Roll":"5"}
  13: 0.16666667 state: {} / returns: {"Roll":"6"}
```
As you can see, the die roll will return with equal probability 1/6.

Once this problem is modeled, the next immediate question would be, how many tosses are needed the result.
That relates to performance modeling, that we will see in the next tutorial.

### What if, we repeat all three tosses, if the result is 0 or 7.
```udiff
@@ -5,8 +5,9 @@
 
 atomic action Roll:
-  toss0 = Toss()
+
   while True:
+    toss0 = Toss()
     toss1 = Toss()
     toss2 = Toss()
```
The result will still produce 1-6 with equal probability. But, the number of tosses will be more.
```bash
   8: 0.16666667 state: {} / returns: {"Roll":"1"}
   9: 0.16666667 state: {} / returns: {"Roll":"2"}
  10: 0.16666667 state: {} / returns: {"Roll":"3"}
  11: 0.16666667 state: {} / returns: {"Roll":"4"}
  12: 0.16666667 state: {} / returns: {"Roll":"5"}
  13: 0.16666667 state: {} / returns: {"Roll":"6"}
```

### What if, we repeat only the last toss, if the result is 0 or 7.
```udiff
@@ -5,8 +5,8 @@
 
 atomic action Roll:
   toss0 = Toss()
+  toss1 = Toss()
   while True:
-    toss1 = Toss()
     toss2 = Toss()
 
     if (toss0 != toss1 or toss0 != toss2):
```
Oops, the probabilities are not equal.
```bash
   8: 0.25000000 state: {} / returns: {"Roll":"1"}
   9: 0.12500000 state: {} / returns: {"Roll":"2"}
  10: 0.12500000 state: {} / returns: {"Roll":"3"}
  11: 0.12500000 state: {} / returns: {"Roll":"4"}
  12: 0.12500000 state: {} / returns: {"Roll":"5"}
  13: 0.25000000 state: {} / returns: {"Roll":"6"}
```

### What if, we use an unfair coin?
Do it as an exercise :)

## Simulating a fair coin with a biased coin
This is another classic, smaller but more interesting example. Given a coin of unknown bias,
how do you simulate a fair coin.
This solution was proposed by von Neumann. Toss the coin twice. If the outcomes are different, return the first outcome.

`samples/fair-coin/FairCoin.fizz`:

```python

atomic func UnfairToss():
    oneof:
        `head` return "head"
        `tail` return "tail"

atomic action FairToss:
    while True:
        toss1 = UnfairToss()
        toss2 = UnfairToss()

        if toss1 != toss2:
            return toss1

```

Set the max_actions to 1 in `fizz.yaml` as before. Also, create a `perf_model_unbiased.yaml` 
and `perf_model_biased.yaml` file as before and set the `UnfairToss.head` and `UnfairToss.tail`
probabilities.

Now, run the model checker.
```bash
./fizz samples/fair-coin/FairCoin.fizz
Model checking samples/fair-coin/FairCoin.json
configFileName: samples/fair-coin/fizz.yaml
StateSpaceOptions: options:{max_actions:1 max_concurrent_actions:1}
Nodes: 6, elapsed: 645.875µs
Time taken for model checking: 662.792µs
Writen graph dotfile: samples/fair-coin/out/run_2024-05-08_01-26-14/graph.dot
To generate svg, run: 
dot -Tsvg samples/fair-coin/out/run_2024-05-08_01-26-14/graph.dot -o graph.svg && open graph.svg
Max Depth 3
PASSED: Model checker completed successfully
Writen 1 node files and 1 link files to dir samples/fair-coin/out/run_2024-05-08_01-26-14

```
Take a look at the graph to visualize how the algorithm works.
    
{{% graphviz %}}
digraph G {
"0x1400002b920" [label="init
Actions: 0, Forks: 0

", color="black" penwidth="2" ];
"0x1400002b920" -> "0x1400002ba40" [label="FairToss[UnfairToss.call]", color="black" penwidth="1" ];
"0x1400002ba40" [label="FairToss
Actions: 1, Forks: 1

Threads: 0/1
", color="black" penwidth="1" ];
"0x1400002ba40" -> "0x140001d47e0" [label="[UnfairToss.head, UnfairToss.call]", color="black" penwidth="1" ];
"0x140001d47e0" [label="Stmt:0
Actions: 1, Forks: 2

Threads: 0/1
", color="black" penwidth="1" ];
"0x140001d47e0" -> "0x1400002ba40" [label="[UnfairToss.head, UnfairToss.call]", color="black" penwidth="1" ];
"0x140001d47e0" -> "0x140001d5d40" [label="[UnfairToss.tail]", color="black" penwidth="1" ];
"0x140001d5d40" [label="yield
Actions: 1, Forks: 3
Returns: {\"FairToss\":\"\"head\"\"}
", color="black" penwidth="2" ];
"0x1400002ba40" -> "0x140001d4a80" [label="[UnfairToss.tail, UnfairToss.call]", color="black" penwidth="1" ];
"0x140001d4a80" [label="Stmt:1
Actions: 1, Forks: 2

Threads: 0/1
", color="black" penwidth="1" ];
"0x140001d4a80" -> "0x140001e0d80" [label="[UnfairToss.head]", color="black" penwidth="1" ];
"0x140001e0d80" [label="yield
Actions: 1, Forks: 3
Returns: {\"FairToss\":\"\"tail\"\"}
", color="black" penwidth="2" ];
"0x140001d4a80" -> "0x1400002ba40" [label="[UnfairToss.tail, UnfairToss.call]", color="black" penwidth="1" ];
}

{{% /graphviz %}}

Now, run the probabilistic model checker with unbiased model.
```bash
bazel-bin/performance/performance_bin \
    --states samples/fair-coin/out/run_2024-05-08_01-26-14/  \
    --source samples/fair-coin/FairCoin.json \
    --perf samples/fair-coin/perf_model_unbiased.yaml
   4: 0.50000000 state: {} / returns: {"FairToss":"\"head\""}
   5: 0.50000000 state: {} / returns: {"FairToss":"\"tail\""}
```

Repeat the same with the biased coin model.
```bash
bazel-bin/performance/performance_bin \
    --states samples/fair-coin/out/run_2024-05-08_01-26-14/  \
    --source samples/fair-coin/FairCoin.json \
    --perf samples/fair-coin/perf_model_biased.yaml
   4: 0.50000000 state: {} / returns: {"FairToss":"\"head\""}
   5: 0.50000000 state: {} / returns: {"FairToss":"\"tail\""}
```
As you can see, the algorithm works as expected. Irrespective of the bias of the coin,
the result is fair.

This is actually an important concept in cryptography. If you have a source of randomness
with unknown bias, you can use this algorithm to generate a fair random number generator
(as long as the source is memory-less, to be precise. That is, even if the coin is biased,
each trial is independent of each other).

## Why is this important?
Probabilistic modeling is important beyond cryptography even to distributed developers.
For example, when you have a number of components with varying error rates, and retries,
what will be your system's overall error rate? Can you have an API that is 99.999% reliable?
If you add more retries, will it lead to timeout at other components, making the retries
less useful and actually detrimental as it contributes to additional load?

We will see more real world examples, in later tutorials after basic performance modeling.

## Conclusion
In this tutorial, we have seen the basics of probabilistic modeling with FizzBee.
Unlike PRISM model checker, FizzBee is incredibly easy to use, and the language is mostly Python.

In the next tutorial, we will see how to model performance of a system.

